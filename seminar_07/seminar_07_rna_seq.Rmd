Seminar 07 - RNA-Seq Analysis
=============================

Runthrough of the two week 7 seminars:

[Getting Read Counts](http://www.ugrad.stat.ubc.ca/~stat540/seminars/seminar07_RNA-seq-bam.html)
[Using read counts for differential expression analysis](http://www.ugrad.stat.ubc.ca/~stat540/seminars/seminar07_RNA-seq.html)

Seminar 7 optional material: From BAM File To Count Data
--------------------------------------------------------

> Contributors: Katayoon Kasaian

## Introduction

> In order to use RNA-Seq data for the purposes of differential expression, we need to begin by calculating an expression value for each gene (or any other expressed entity such as exons, non-coding RNAs, etc). The digital nature of RNA-seq data allows us to use the number of reads which align to a specific feature as its expression value. In this seminar, we will analyze a small subset of an alignment file and find the read counts for each gene in that region.

## BAM/SAM - Aligned Sequence Data File Format

> The alignment BAM file we will be working with is from the transcriptome of Drosophila melanogaster (fruit fly). [SAM: Sequence Alignment/Map](http://bioinformatics.oxfordjournals.org/content/early/2009/06/08/bioinformatics.btp352.full.pdf) format as well as BAM (binary version of SAM) have become popular formats for representing the alignment of short reads to the reference genome. [Samtools](http://samtools.sourceforge.net/samtools.shtml) package has been developed for working with SAM/BAM alignment files. Several packages have been introduced in order to bring the functionality of Samtools into the R environment. We will work with a few of these packages today.

## Preliminaries

> If you already haven't done so, please install the following packages from Bioconductor.

```{r, eval=FALSE}
source("http://bioconductor.org/biocLite.R")
biocLite("ShortRead")
biocLite("Rsamtools")
biocLite("easyRNASeq")
biocLite("BSgenome.Dmelanogaster.UCSC.dm3")
biocLite("biomaRt")
```

## Reading BAM Files

> We start by importing the BAM file, [drosophilaMelanogasterSubset.bam](../examples/drosophilaRnaSeq/data/drosophilaMelanogasterSubset.bam):

> Remember you may need to edit the file paths below, to reflect your working directory and local file storage choices.

```{r, warning=FALSE, message=FALSE}
library(ShortRead)
library(Rsamtools)

bamDat <- readAligned("../../../stat540/stat540_2014/examples/drosophilaRnaSeq/data/drosophilaMelanogasterSubset.bam", type="BAM")

#bamDat is an AlignedRead object from the ShortRead package. It stores reads and their genomic alignment information.
str(bamDat)
```

> Note that in addition to the drosophilaMelanogasterSubset.bam file, there is an index file called drosophilaMelanogasterSubset.bam.bai. This index file allows fast look up of data from the binary alignment file. To index a bam file, you can use the following code:

```{r, eval=FALSE}
indexFile <- indexBam("../../../stat540/stat540_2014/examples/drosophilaRnaSeq/data/drosophilaMelanogasterSubset.bam")
```

> This will create the index file `../examples/drosophilaRnaSeq/data/drosophilaMelanogasterSubset.bam.bai`, note that ".bai" has been appended to the original file name.

## Filtering BAM Files

> BAM files contain all the read sequences coming off the sequencing machine, including those that were not aligned to the reference genome! Some reads also contain one or more ambiguous bases encoded as 'N'. As a result, we need to do some filtering before finding expression values for genes.

> First we will load the [easyRNASeq](http://www.bioconductor.org/packages/2.11/bioc/html/easyRNASeq.html) library which provides convenient methods for manipulating BAM files.

```{r, warning=FALSE, message=FALSE}
library(easyRNASeq)
```

> Now we will do some filtering. The first filter we want to create will keep only reads with at most 2 N's. The `nFilter` functions provides this functionality.

```{r}
nFilt <- nFilter(2)
```

> Next we will create a filter to keep only reads which have been aligned to the reference genome. The `chromosomeFilter` function will keep only reads which have an entry in the chromosome field of the BAM file satifying a given pattern. We can exploit this by filtering for reads in which the chromsome entry in the BAM file has the string "chr" in them.

> This works because reads which have been aligned to the reference genome will have the chromosome field set to chromosome to which the read has been aligned. Unaligned reads will not have this entry set or it will be something which does not contain "chr".

> If the reference genome used for alignment did not have "chr" in the names of the chromosomes this trick would fail. This is a common issue, for example some versions of the human reference use "chr1" to identify chromsome 1 while others simply use "1".

```{r}
chrFilt <- chromosomeFilter(regex="chr")
```

> Now we would like to create a new filter which checks that both conditions are satisfied i.e. a read has 2 or fewer N's and is aligned to the reference genome. We can do this using the `compose` function which will create a new filter that is only satisfied if each constituent filter is satisfied.

```{r}
filt <- compose(nFilt, chrFilt)
```

> Finally we apply the filter to extract the relevant subset of data.

```{r}
bamDatFiltered <- bamDat[filt(bamDat)]
```

### Examining BAM Data

> We can examine the filtered BAM file and the annotations stored in `bamDatFiltered` object.

> Like most R objects the `str` function gives us a nice human readable description of the object.

```{r}
str(bamDatFiltered)
```

> If we wanted to see which chromosomes were present we could use `chromosome` function. This functions pulls out the chromosome field for all reads in the `bamDatFiltered` object. Rather than look at these values for each read, we will just look at which chromosomes are present using the `levels` function.

```{r}
levels(chromosome(bamDatFiltered))
```

> We can look at the read IDs for each read using the `id` function. The next piece of code will look at the IDs for the first 10 reads in the file.

```{r}
id(bamDatFiltered)[1:10]
```

> If we want to see the DNA sequence for the read we can use the `sread` method.

```{r}
sread(bamDatFiltered)[1:10]
```

> An important point about sequencing data is that sometimes nucleotides can be incorrectly read by the sequencing machines. Base qualities are used to quantify how likely the observed nucleotide is to be correct. We can look at the base qualities using the `quality` function.

```{r}
quality(bamDatFiltered)[1:10]
```

> You'll notice the qualities are not numbers but ASCII characters. There is a formula specified in the SAM format for converting the character values into integer PHRED scores.

> We can find out the starting (left most) position where the read was aligned on the chromosome using the `position` function.

```{r}
position(bamDatFiltered)[1:10]
```

> We can also see which strand (forward/+ or reverse/-) the read was aligned to using the `strand` function.

```{r}
strand(bamDatFiltered)[1:10]
```

> What are the differences between the filtered and unfiltered BAM files?

The filtered file:

- Contains fewer reads - 56,883 vs. 62,206.
- Contains only reads aligning to chromosomes, with less than or equal to 2 N's in each read sequence.

> What are the chromosomes with aligned reads from the BAM file?

```{r}
levels(chromosome(bamDatFiltered))
```

Get counts:

```{r}
df <- data.frame(id = id(bamDatFiltered), chrom = chromosome(bamDatFiltered))
summary(df$chrom)
```

## Accessing Genome Annotations

> Aligned read data is not much use without information about the genome it was aligned to. We will make use of the Drosophila database accessed through R to get some information about the Drosophila genome.

> First we will load the genomic database.

```{r}
library(BSgenome.Dmelanogaster.UCSC.dm3)
```

> Now we can get the length of the chromsomes in the genome.

```{r}
(chrSizes <- seqlengths(Dmelanogaster))
```

> For the purposes of the seminar, we will only look at one chromosome, chr2L, and find the counts for genes on this chromosome. We use the BioMart functionality of the Ensembl database to retrieve the annotations of Drosophila melagoaster chromosome 2L.

> The first step will be to load the `biomaRt` library and specify that we want the Drospohila database.

```{r}
library(biomaRt)
ensembl <- useMart("ensembl", dataset="dmelanogaster_gene_ensembl")
```

> Now we can download the genome annotation data. First we will define a set of fields we are interested for each gene. We will get the ENSEMBl gene ID, the strand the gene is on, the chromosome the gene is on, the start position of the gene on that chromosome and the end position of the gene.

```{r}
annotation.fields <- c("ensembl_gene_id",
                        "strand",
                        "chromosome_name",
                        "start_position",
                        "end_position")
```

> Now we can download the actual annotation data. Because were are restricting attention to chr2L we will use the `filter` argument of the `getBM` function.

```{r}
gene.annotation <- getBM(annotation.fields,
                         mart=ensembl,
                         filters="chromosome_name",
                         values=c("2L"))
str(gene.annotation)
```

> Lets check that we only downloaded annotations for chromosome 2L.

```{r}
levels(as.factor(gene.annotation$chromosome))
```

> Now you'll notice the chromosome name lacks the "chr" prefix. This will cause issues as the BAM file we are using has uses the "chr" prefix to identify chromosomes. To rectify this we will add "chr" to the annotation data.

```{r}
gene.annotation$chromosome <- paste("chr", gene.annotation$chromosome_name, sep='')
levels(as.factor(gene.annotation$chromosome))
```

> Two R packages, GRanges and IRanges, become handy when dealing with problems in genomics. For instance, they can be used for annotating the genome and storing the data.

> Example: annotating all the exons would require storing the information regarding their location. These intervals (the start and end of every exon) can be stored in an IRanges object. GRanges object can also store information regarding chromosome (seqnames) and strand and hence more specific to genomics.

```{r}
#We store the gene annotation information in an IRanges object
gene.range <- RangedData(IRanges(start=gene.annotation$start_position,
                                 end=gene.annotation$end_position),
                                 space=gene.annotation$chromosome,
                                 strand=gene.annotation$strand,
                                 gene=gene.annotation$ensembl_gene_id,
                                 universe="Dm3")

show(gene.range)
```

### Calculating Coverage

> To do a differential expression analysis we will need data about how many reads align to a given gene. We can compute this type of coverage data using the `coverage` function.

> First lets find out how many bases cover each position in every chromosome.

```{r}
(cover <- coverage(bamDatFiltered, width=chrSizes))
```

> For differential expression analysis we will need coverage on a per gene basis.

```{r}
#Aggregating the coverage for each gene
gene.coverage <- aggregate(cover[match(names(gene.range),names(cover))],
                           ranges(gene.range),sum)

#Finding the number of reads covering each gene
gene.coverage <- ceiling(gene.coverage/unique(width(bamDat)))
gene.coverage
```

> Restricting attention to chr2L.

```{r}
# Note that the number of entities with coverage count on chromosome 2L is equal to the number of genes on chromosome 2L.
length(gene.coverage[["chr2L"]])
length(ranges(gene.range)$chr2L)
```

> Using the coverage and gene annotation data, we can now build a count table and store it in a data frame.

```{r}
countTable <- data.frame(chromosome=gene.range$space,
                         gene_start=start(gene.range$ranges),
                         gene_end=end(gene.range$ranges),
                         strand=gene.range$strand,
                         gene=gene.range$gene,
                         count=as.vector(gene.coverage[["chr2L"]]))
dim(countTable)
head(countTable)
```

> Some methods for doing differential expression analysis such as [edgeR](http://www.bioconductor.org/packages/2.11/bioc/html/edgeR.html) can work from the raw count data.

> Other methods use normalized coverage statistics. The calculated raw number of read counts need to be normalizes for two reasons:

> 1. Longer genes will have more reads aligned to them, thus we need to normalize the read count by gene length.

> 2. Libraries with larger overall number of reads will have more reads aligned to genes compared with a library with less number of total reads. As a result, the normalization should also take into account the library size (total number of reads generated).

> The most widely used normalization value is RPKM defined as the "number of Reads Per Kilobase of gene (feature) per Million mapped reads" (Mortazavi et al, 2008).

```{r}
countTable <- data.frame(chromosome=gene.range$space,
                         gene_start=start(gene.range$ranges),
                         gene_end=end(gene.range$ranges),
                         strand=gene.range$strand,
                         gene=gene.range$gene,
                         count=as.vector(gene.coverage[["chr2L"]]),
                         RPKM=(as.vector(gene.coverage[["chr2L"]])/(end(gene.range$ranges) - start(gene.range$ranges)))*(1000000000/length(bamDat)))
head(countTable)
```

## Take Home Problem
> Create a similar count table for all the exons located on chr2L.

To do this, I'd need to re-download the data from Ensembl to get the exon coordinates.

## References
> This seminar is based on a Bioconductor [RNA-Seq tutorial](http://www.bioconductor.org/packages/2.11/data/experiment/html/RnaSeqTutorial.html)
