Seminar 04 - Two group comparisons and data aggregation
========================================================

Preamble
--------

Load in the datasets:

```{r}
library(lattice)
library(ggplot2)
prDat <- read.table("../../../stat540/stat540_2014/examples/photoRec/data/GSE4051_data.tsv")
str(prDat, max.level = 0)
prDes <- readRDS("../../../stat540/stat540_2014/examples/photoRec/data/GSE4051_design.rds")
str(prDes)
```

Two sample tests -- one gene
----------------------------

Pick a single gene, somewhat randomly:

```{r}
set.seed(987)
(theGene <- sample(1:nrow(prDat), 1))
```

Make a new data frame, using the field descriptions, plus the gene expression values for the selected gene:

```{r}
pDat <- data.frame(prDes, gExp = unlist(prDat[theGene, ])) 
str(pDat)
```

Calculate the means for each genotype:

```{r}
aggregate(gExp ~ gType, pDat, FUN = mean)
```

A stripplot to sanity-test the t-test result:

```{r}
stripplot(gType ~ gExp, pDat)
```

Next, do a simple t-test:

```{r}
t.test(gExp ~ gType, pDat)
```

Then, save the object to inspect it:

```{r}
ttRes <- t.test(gExp ~ gType, pDat)
str(ttRes)
```

Extract some useful components:

```{r}
ttRes$statistic
ttRes$p.value
```

*Next: You try: draw a different gene at random or pick one for biological interest and look up the Affy probe ID. Use the t test, with and without the common variance assumption, the Wilcoxon, and/or the Kolmogorov-Smirnov test to assess differential expression. Can you pull test statistics and/or p-values from the different approaches into an common object, like a readable table? Are you getting the same message from the various approaches? Hint: wilcox.test(), ks.test().*

Pick a different gene randomly:

```{r}
set.seed(1124)
(theGene <- sample(1:nrow(prDat), 1))
```

Look up the Affy probe ID:

```{r}
row.names(prDat[theGene,])
```

Plots and means for sanity-checking:

```{r}
aggregate(gExp ~ gType, pDat, FUN = mean)
stripplot(gType ~ gExp, pDat)
(p <- ggplot(pDat) + geom_density(aes(x=gExp, colour=gType)))
```

Use the t test, with and without the common variance assumption:

```{r}
pDat <- data.frame(prDes, gExp = unlist(prDat[theGene, ])) 
(ttRes <- t.test(gExp ~ gType, pDat))
```

Without common variance assumption:

```{r}
(ttRes_equal_var <- t.test(gExp ~ gType, pDat, var.equal=TRUE))
```

Wilcoxon, Kolmogorov-Smirnov:

```{r}
(wilcoxRes <- wilcox.test(gExp ~ gType, pDat, exact = FALSE))
wt <- subset(pDat, gType == 'wt')
ko <- subset(pDat, gType == 'NrlKO')
(ksRes <- ks.test(wt$gExp, ko$gExp, exact = FALSE))
```

Pull test stats into a common object:

```{r}
(test_names <- c("t-test", "t-test, equal variance", "Wilcoxon", "Kolmogorov-Smirnov"))
(p_vals <- c(ttRes$p.value, ttRes_equal_var$p.value, wilcoxRes$p.value, ksRes$p.value))
df <- data.frame(test_names, p_vals)
```

*this is a start, but could probably be a little nicer*

Data Aggregation digression
---------------------------

### Install and load `plyr`, and the gapminder data set

```{r}
install.packages("plyr", dependencies = TRUE)
library(plyr)
gdURL <- "http://www.stat.ubc.ca/~jenny/notOcto/STAT545A/examples/gapminder/data/gapminderDataFiveYear.txt"
gDat <- read.delim(file = gdURL)
```

Check out the data frame:

```{r}
str(gDat)
summary(gDat)
```

### `ddply`

```{r}
(maxLeByCont <- ddply(gDat, ~ continent, summarize, maxLifeExp = max(lifeExp)))
str(maxLeByCont)
levels(maxLeByCont$continent)
```

I read this as "take the data frame `gDat`, split it up by continent, then summarize by getting the max life expectancy, and turn it back into a new data frame"

*You try: compute the minimum GDP per capita by continent. Here's what I get:*

```{r}
(minGDPeByCont <- ddply(gDat, ~ continent, summarize, minGDP = min(gdpPercap)))
```

Build the function inline:

```{r}
ddply(gDat, ~continent, summarize, nUniqCountries = length(unique(country)))
```

Without `summarize`:

```{r}
ddply(gDat, ~ continent,
      function(x) return(c(nUniqCountries = length(unique(x$country)))))
```

*Note: that looks like a Python lambda*

Multiple columns:

```{r}
ddply(gDat, ~ continent, summarize,
      minLifeExp = min(lifeExp), maxLifeExp = max(lifeExp),
      medGdpPercap = median(gdpPercap))
```

### Putting it all together: using `ddply()` and polishing the results

```{r}
jCountry <- "France"  # pick, but do not hard wire, an example
(jDat <- subset(gDat, country == jCountry))  # temporary measure!
```

Plot to check:

```{r}
xyplot(lifeExp ~ year, jDat, type = c("p", "r"))  # always plot the data
(p <- ggplot(jDat, aes(year, lifeExp)) + geom_point() + geom_smooth())
```

Fit a linear model:

```{r}
jFit <- lm(lifeExp ~ year, jDat)
summary(jFit)
```

Re-parameterize to start at 1952:

```{r}
(yearMin <- min(gDat$year))
jFit <- lm(lifeExp ~ I(year - yearMin), jDat)
summary(jFit)
```

Skip ahead to get the rest:

```{r}
jFun <- function(x) {
    estCoefs <- coef(lm(lifeExp ~ I(year - yearMin), x))
    names(estCoefs) <- c("intercept", "slope")
    return(estCoefs)
}
## jFun(subset(gDat, country == 'India')) to see what it does
jCoefs <- ddply(gDat, ~country, jFun)
```

Format as an HTML table:

```{r}
install.packages("xtable", dependencies = TRUE)
library(xtable)
set.seed(916)
foo <- jCoefs[sample(nrow(jCoefs), size = 15), ]
foo <- xtable(foo)
```

Print it out:

```{r results='asis'}
print(foo, type = "html", include.rownames = FALSE)
```

Back to the Data Aggregation Seminar
------------------------------------




